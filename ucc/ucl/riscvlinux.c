#include "ucl.h"
#include "target.h"
#include "riscv_reg.h"
#include "output.h"

static int ORG;
static int FloatNum;

static char *ASMTemplate[] = {
#define TEMPLATE(code, str) str,
#include "riscvlinux.tpl"
#undef TEMPLATE
};


static char* GetAccessName(Symbol p) {
	if (p->aname != NULL) {
		return p->aname;
	}
	switch (p->kind) {
		case SK_Constant:
			p->aname = FormatName("$%s", p->name);
			break;
		case SK_String: case SK_Label:
			p->aname = FormatName(".%s", p->name);
			break;
		case SK_Variable: case SK_Temp:
			if (p->level == 0 || p->sclass == TK_EXTERN) {
				p->aname = p->name;
			} else if (p->sclass == TK_STATIC) {
				p->aname = FormatName("%s.%d", p->name, TempNum++);
			} else {
				//assert("GetAccessName error 1" && 0);
				p->aname = FormatName("%d(fp)", AsVar(p)->offset);
			}
			break;
		case SK_Function:
			p->aname = p->name;
			break;
		case SK_Offset:
			{
				Symbol base = p->link;
				int n = AsVar(p)->offset;
				if (base->level == 0 || base->sclass == TK_STATIC || base->sclass == TK_EXTERN) {
					p->aname = FormatName("%s%s%d", GetAccessName(base), n >= 0 ? "+" : "", n);
				} else {
					assert("GetAccessName error 2" && 0);
				}
			}
			break;
		default:
			assert(0);
	}
	return p->aname;
}


static void Align(Symbol p) {
	int align = p->ty->align;
	if (ORG % align != 0) {
		Print(".align %d\n", align);	
		ORG = ALIGN(ORG, align);
	}
	ORG += p->ty->size;
}

void SetupRegisters(void) {
	riscvRegs[ZERO] = CreateReg("zero", NULL, ZERO);	
	riscvRegs[RA] = CreateReg("ra", "(ra)", RA);	
	riscvRegs[SP] = CreateReg("sp", "(sp)", SP);	
	riscvRegs[GP] = CreateReg("gp", "(gp)", GP);	
	riscvRegs[TP] = CreateReg("tp", "(tp)", TP);	
	riscvRegs[T0] = CreateReg("t0", "(t0)", T0);	
	riscvRegs[T1] = CreateReg("t1", "(t1)", T1);	
	riscvRegs[FP] = CreateReg("fp", "(fp)", FP);	
	riscvRegs[S1] = CreateReg("s1", "(s1)", S1);	
	riscvRegs[A0] = CreateReg("a0", "(a0)", A0);	
	riscvRegs[A1] = CreateReg("a1", "(a1)", A1);	
	riscvRegs[A2] = CreateReg("a2", "(a2)", A2);	
	riscvRegs[A3] = CreateReg("a3", "(a3)", A3);	
	riscvRegs[A4] = CreateReg("a4", "(a4)", A4);	
	riscvRegs[A5] = CreateReg("a5", "(a5)", A5);	
	riscvRegs[A6] = CreateReg("a6", "(a6)", A6);	
	riscvRegs[A7] = CreateReg("a7", "(a7)", A7);	
	riscvRegs[S2] = CreateReg("s2", "(s2)", S2);	
	riscvRegs[S3] = CreateReg("s3", "(s3)", S3);	
	riscvRegs[S4] = CreateReg("s4", "(s4)", S4);	
	riscvRegs[S5] = CreateReg("s5", "(s5)", S5);	
	riscvRegs[S6] = CreateReg("s6", "(s6)", S6);	
	riscvRegs[S7] = CreateReg("s7", "(s7)", S7);	
	riscvRegs[S8] = CreateReg("s8", "(s8)", S8);	
	riscvRegs[S9] = CreateReg("s9", "(s9)", S9);	
	riscvRegs[S10] = CreateReg("s10", "(s10)", S10);	
	riscvRegs[S11] = CreateReg("s11", "(s11)", S11);	
	riscvRegs[T3] = CreateReg("t3", "(t3)", T3);	
	riscvRegs[T4] = CreateReg("t4", "(t4)", T4);	
	riscvRegs[T5] = CreateReg("t5", "(t5)", T5);	
	riscvRegs[T6] = CreateReg("t6", "(t6)", T6);	
}

void DefineString(String str, int size) {
	int i = 0;
	if (str->chs[size - 1] == 0) {
		PutString(".string\t\"");
		size--;
	} else {
		PutString(".ascii\t\"");
	}
	while (i < size) {
		if (! isprint(str->chs[i])){
			Print("\\%03o", (unsigned char)str->chs[i]);
		} else {
			if (str->chs[i] == '"') {
				PutString("\\\"");
			} else if (str->chs[i] == '\\') {
				PutString("\\\\");
			} else {
				PutChar(str->chs[i]);
			}
		}
		i++;
	}
	PutString("\"\n");
}


void DefineValue(Type ty, union value val) {
	int tcode = TypeCode(ty);
	switch (tcode) {
		case I1: case U1:
			Print(".byte\t%d\n", val.i[0] & 0xff);
			break;
		case I2: case U2:
			Print(".word\t%d\n", val.i[0] & 0xffff);
			break;
		case I4: case U4:
			Print(".long\t%d\n", val.i[0]);
			break;
		case F4:
			Print(".long\t%d\n", *(unsigned *)&val.f);
			break;
		case F8:
			{
				unsigned *p = (unsigned *)&val.d;
				Print(".long\t%d\n.long\t%d\n", p[0], p[1]);
				break;
			}
		default:
			assert(0);
	}
}

void DefineFloatConstant(Symbol p) {
	int align = p->ty->align;
	p->aname = FormatName(".flt%d", FloatNum++);
	Align(p);
	Print("%s:\t", p->aname);
	DefineValue(p->ty, p->val);
}

void Import(Symbol p) {}
void DefineCommData(Symbol p) {
	GetAccessName(p);
	if (p->sclass = TK_STATIC) {
		Print(".lcomm\t%s,%d\n", p->aname, p->ty->size);
	} else {
		Print(".comm\t%s,%d\n", p->aname, p->ty->size);
	}
}
void Space(int size) {
	Print(".space\t%d\n", size);
}
void DefineAddress(Symbol p) {
	Print(".long\t%s", GetAccessName(p));
}

void BeginProgram() {
	int i;
	ORG = 0;
	FloatNum = TempNum = 0;
	for (i = ZERO; i <= T6; i++) {
		if (riscvRegs[i] != NULL) {
			riscvRegs[i]->link = NULL;
		}	
	}
	PutString("# Code auto-generated by ustc-sse-riscvcc\n\n");
}


void Segment(int seg) {
	if (seg == DATA) {
		PutString(".data\n\n");	
	} else if (seg == CODE) {
		PutString(".text\n\n");	
	}
}


void Export (Symbol p) {
	Print(".globl\t%s\n\n", GetAccessName(p));
}

void DefineGlobal(Symbol p) {
	Align(p);
	if (p->sclass != TK_STATIC) {
		Export(p);
	}
	Print("%s:\t", GetAccessName(p));
}

void DefineLabel(Symbol p) {
	Print("%s:\n", GetAccessName(p));
}

void EndProgram(void) {
	Flush();
}

void PutASMCode(int code, Symbol opds[]) {
	char *fmt = ASMTemplate[code];
	int i;
	PutChar('\t');
	while (*fmt) {
		switch(*fmt) {
			case ';':
				PutString("\n\t");
				break;
			case '%':
				fmt++;
				if (*fmt == '%') {
					PutChar('%');
				} else {
					i = *fmt - '0';
					if (opds[i]->reg != NULL) {
						PutString(opds[i]->reg->name);
					} else {
						PutString(GetAccessName(opds[i]));
					}
				}
				break;
			default:
				PutChar(*fmt);
				break;
		}
		fmt++;
	}
	PutChar('\n');
}
